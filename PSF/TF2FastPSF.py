# -*- coding: utf-8 -*-
"""MBBhuBeadWithLBFGSB.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12l5h7me8HSlALn8mkw9k6gkZZOpTPhuK
"""

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 2.x
from math import *
import matplotlib
if os.environ.get('DISPLAY','') == '':
    print('no display found. Using non-interactive Agg backend')
    matplotlib.use('Agg')
import tensorflow as tf
import tensorflow_probability as tfp
import sys
import scipy.special
from scipy.interpolate import interp1d
import numpy as np
from scipy.io import loadmat
import matplotlib.pyplot as plt
plt.style.use('seaborn-whitegrid')

print(tf.config.list_physical_devices('GPU'))

"""Load the forward images"""

annots = loadmat('data//SimTunableA5BhuBead.mat')
g = annots['g']
print(np.shape(g))
g = np.transpose(g, (3, 4, 2, 0, 1)) # permute the array to [Nthe, Nphi, Z, X, Y]
Nthe, Nphi, Z, X, Y = np.shape(g)

"""Load the PSF and the patterns"""

res = loadmat('data//hBhuBead.mat')
h   = res['h']
h   = np.transpose(h, (2, 0, 1))  # permute the array to [Z, X, Y]
res = loadmat('data//imBhuBead.mat')
im  = res['im']
im  = np.transpose(im, (5, 3, 4, 2, 0, 1)) # permute the array to [Nm, Nthe, Nphi, Z, X, Y]
res = loadmat('data//jmBhuBead.mat')
jm  = res['jm']
jm  = np.transpose(jm, (5, 3, 4, 2, 0, 1)) # permute the array to [Nm, Nthe, Nphi, Z, X, Y]

def flip_from_dim(data, dim):
    for i in range(dim, len(data.shape)):
        data = np.flip(data,i) #Reverse given tensor on dimention i
    return data


guess = np.zeros((Z,X,Y))
for l in range(Nthe):
  for k in range(Nphi):
    guess = guess + g[l,k,:,:,:]
guess = guess/(Nthe*Nphi)
plt.style.use('classic')
plt.figure(figsize=(8, 3.5))
plt.subplot(1,2,1)
plt.imshow(guess[150,:,:], cmap='gray')
plt.subplot(1,2,2)
plt.imshow(guess[:,100,:], cmap='gray')
plt.show()
plt.savefig('guess.png')

def FastPSF(size_x, size_y, size_z, ts):
  # Precision control
  num_basis    = tf.convert_to_tensor(150 , tf.int32)  # Number of rescaled Bessels that approximate the phase function
  num_samples  = tf.convert_to_tensor(2000, tf.int32)  # Number of pupil samples along radial direction
  oversampling = tf.convert_to_tensor(1   , tf.int32)  # Defines the upsampling ratio on the image space grid for computations

  # Microscope parameters
  NA          = tf.convert_to_tensor(1.4  , tf.float32)
  wavelength  = tf.convert_to_tensor(0.515, tf.float32) # microns
  ns          = tf.convert_to_tensor(1.47 , tf.float32) # specimen refractive index (RI)
  ng0         = tf.convert_to_tensor(1.518, tf.float32) # coverslip RI design value
  ng          = tf.convert_to_tensor(1.518, tf.float32) # coverslip RI experimental value
  ni0         = tf.convert_to_tensor(1.518, tf.float32) # immersion medium RI design value
  ni          = tf.convert_to_tensor(1.518, tf.float32) # immersion medium RI experimental value
  ti0         = tf.convert_to_tensor(190  , tf.float32) # microns, working distance (immersion medium thickness) design value
  tg0         = tf.convert_to_tensor(170  , tf.float32) # microns, coverslip thickness design value
  tg          = tf.convert_to_tensor(170  , tf.float32) # microns, coverslip thickness experimental value
  res_lateral = tf.convert_to_tensor(0.1  , tf.float32) # microns
  res_axial   = tf.convert_to_tensor(0.1  , tf.float32) # microns
  pZ          = tf.convert_to_tensor(0.0  , tf.float32) # microns, particle distance from coverslip
  #pZ          = 2     # microns, particle distance from coverslip

  # Scaling factors for the Fourier-Bessel series expansion
  min_wavelength = tf.convert_to_tensor(0.436, tf.float32) # microns
  scaling_factor = NA * tf.cast(3 * tf.range(1, num_basis + 1) - 2, tf.float32) * min_wavelength / wavelength
  #print(scaling_factor)

  # Place the origin at the center of the final PSF array
  x0 = (size_x - 1) / 2
  y0 = (size_y - 1) / 2

  # Find the maximum possible radius coordinate of the PSF array by finding the distance
  # from the center of the array to a corner
  max_radius = round(sqrt((size_x - x0) * (size_x - x0) + (size_y - y0) * (size_y - y0))) + 1;

  # Radial coordinates, image space
  r = res_lateral * tf.cast(tf.range(0, oversampling * max_radius), tf.float32) / tf.cast(oversampling, tf.float32)

  # Radial coordinates, pupil space
  a   = tf.convert_to_tensor(min([NA, ns, ni, ni0, ng, ng0]) / NA, tf.float32)
  rho = tf.linspace(0.0, a, num_samples)

  # Stage displacements away from best focus
  #z = res_axial * np.arange(-size_z / 2, size_z /2) + res_axial / 2
  z = res_axial * tf.cast(tf.range(-size_z / 2, size_z /2), tf.float32)

  # Define the wavefront aberration
  OPDs = ts * tf.sqrt(ns * ns - NA * NA * rho * rho) # OPD in the sample
  ti   = ni * (-tg/ng + tg0/ng0 + ti0/ni0 - ts/ns)
  OPDi = (tf.reshape(z, [-1,1]) + pZ + ti) * tf.sqrt(ni * ni - NA * NA * rho * rho) - ti0 * tf.sqrt(ni0 * ni0 - NA * NA * rho * rho) # OPD in the immersion medium
  OPDg = tg * tf.sqrt(ng * ng - NA * NA * rho * rho) - tg0 * tf.sqrt(ng0 * ng0 - NA * NA * rho * rho) # OPD in the coverslip
  W    = 2 * tf.cast(tf.constant(np.pi), tf.float32) / wavelength * (OPDs + OPDi + OPDg)

  # Define the basis of Bessel functions
  # Shape is (number of basis functions by number of rho samples)
  J = tf.cast(scipy.special.jv(0, tf.reshape(scaling_factor, [-1, 1]) * rho), tf.float32)

  # Sample the phase
  # Shape is (number of z samples by number of rho samples)
  phaseRe = tf.cos(W)
  phaseIm = tf.sin(W)

  # Compute the approximation to the sampled pupil phase by finding the least squares
  # solution to the complex coefficients of the Fourier-Bessel expansion.
  # Shape of C is (number of basis functions by number of z samples).
  # Note the matrix transposes to get the dimensions correct.
  CRe = tf.linalg.lstsq(tf.transpose(J), tf.transpose(phaseRe), l2_regularizer = 0.01)
  CIm = tf.linalg.lstsq(tf.transpose(J), tf.transpose(phaseIm), l2_regularizer = 0.01)
  C   = tf.complex(CRe, CIm)

  b = tf.cast(2 * np.pi * tf.reshape(r, [-1, 1]) * NA / wavelength, tf.float32)

  # Convenience functions for J0 and J1 Bessel functions
  #J0 = lambda x: tf.math.bessel_i0e(x)
  #J1 = lambda x: tf.math.bessel_i1e(x)
  J0 = lambda x: scipy.special.jv(0, x)
  J1 = lambda x: scipy.special.jv(1, x)

  # See equation 5 in Li, Xue, and Blu
  denom = scaling_factor * scaling_factor - b * b
  R = (scaling_factor * tf.cast(J1(scaling_factor * a),tf.float32) * tf.cast(J0(b * a),tf.float32) * a - b * tf.cast(J0(scaling_factor * a) * J1(b * a),tf.float32) * a)
  R /= denom

  # The transpose places the axial direction along the first dimension of the array, i.e. rows
  # This is only for convenience.
  PSF_rz = tf.transpose(tf.abs( tf.matmul(tf.cast(R, tf.complex64), C) )**2)
  
  # Normalize to the maximum value
  PSF_rz /= np.max(PSF_rz.numpy())

  # Create the fleshed-out xy grid of radial distances from the center
  xy      = np.mgrid[0:size_y, 0:size_x]
  r_pixel = np.sqrt((xy[1] - x0) * (xy[1] - x0) + (xy[0] - y0) * (xy[0] - y0)) * res_lateral.numpy()
  r_pixel = tf.cast(r_pixel.ravel(), tf.float32);
  x_ref_min = tf.cast(min(r), tf.float32)
  x_ref_max = tf.cast(max(r), tf.float32)

  output_list = []
  for z_index in range(size_z):
      # Evaluate the PSF at each value of r_pixel
      output_list.append(tf.reshape(tfp.math.interp_regular_1d_grid(r_pixel,x_ref_min,x_ref_max,PSF_rz[z_index, :]), [size_y, size_x]))
  PSF = tf.stack(output_list)

  #print(tf.transpose(PSF, [1, 2, 0]))
  return PSF
  #return PSF_rz
  #return tf.reduce_sum(PSF_rz)

size_x = 200
size_y = 200
size_z = 300

#hTf  = tf.constant(h , dtype=tf.complex64)
imTf = tf.constant(im, dtype=tf.complex64)
jmTf = tf.constant(jm, dtype=tf.complex64)
gTf  = tf.convert_to_tensor(g, dtype=tf.float32)

def costFct(inVar):
  m       = inVar[:-1]
  ts      = inVar[-1]
  mRe     = tf.dtypes.cast(tf.reshape(m, [300, 200, 200]), dtype=tf.complex64)
  curCost = 0.0;
  for l in range(Nthe):
    for k in range(Nphi):
      hTf  = tf.cast(FastPSF(size_x, size_y, size_z, ts) , dtype=tf.complex64)
      objm = mRe*jmTf[1,l,k,:,:,:]
      him  = hTf*imTf[1,l,k,:,:,:]
      G    = tf.signal.fft3d(mRe)*tf.signal.fft3d(hTf) + tf.signal.fft3d(objm)*tf.signal.fft3d(him)
      gCur = tf.math.real(tf.signal.ifftshift(tf.signal.ifft3d(G)))
      curCost = curCost + tf.reduce_sum(tf.square(gCur - gTf[l,k,:,:,:]))
  print(curCost)
  return curCost

temp = np.reshape(guess,(300*200*200))
temp = np.append(temp, -3)
start = tf.Variable(initial_value=temp, shape=(300*200*200+1), dtype=tf.float32)
optim_results = tfp.optimizer.lbfgs_minimize(
    lambda m: tfp.math.value_and_gradient(costFct, m),
    initial_position=start,
    num_correction_pairs=10,
    max_iterations=400,
    tolerance=1e-8,
)

temp = np.reshape(guess,(300*200*200))
temp = np.append(temp, -5)
print(temp.shape)

reconOb = optim_results.position.numpy()
print(reconOb[-1])
reconOb[reconOb < 0] = 0
reconOb = reconOb[:-1]
reconOb = np.reshape(reconOb, (300,200,200))
plt.style.use('classic')
plt.figure(figsize=(8, 3.5))
plt.subplot(1,2,1)
plt.imshow(reconOb[150,:,:], cmap='gray')
plt.subplot(1,2,2)
plt.imshow(reconOb[:,100,:], cmap='gray')
plt.show()
plt.savefig('reconOb.png')